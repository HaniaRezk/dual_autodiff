\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{subfigure}

\title{\Huge \textbf{C1 Research Computing Coursework Report}} 
\author{Hania Rezk (hhmmer2) \\ 
\\
MPhil Data Intensive Science, Department of Physics}
\date{26 November 2024}

\begin{document}

\maketitle


\noindent \textbf{Word count:} [1000] \\

\newpage  
\tableofcontents

\newpage  


\section{Introduction}
This report discusses the development of a Python package that performs automatic differentiation using dual numbers. Dual numbers, represented as $x = a + b\epsilon$, consist of a real part $a$, and a dual part $b$ carried by $\epsilon$ that satisfies $\epsilon^2 = 0$. These numbers are used to compute derivatives efficiently; this approach, called forward-mode automatic differentiation, is particularly valuable in fields like machine learning as it enables fast training of deep neural networks.

\vspace{10pt}

This report describes the step-by-step creation of this package, its test suite, its documentation and finally the process of cynthonising it. This report also contains the answers to the questions of the coursework sheet. 

\section{ \texttt{ Dual\_autodiff} Package Structure and Project Configuration}
This package respects the structure seen in the Research Computing course as shown below.

\begin{verbatim}
    .
    +-- pyproject.toml               # Configuration 
    +-- README.md                    # Instructions
    +-- dual_autodiff/               # Package folder with codes
    |   +-- __init__.py
    |   +-- version.py               # Manage package versions
    |   +-- dual.py                  # Dual class
    +-- dist/                        # Distribution files
    +-- docs/                        # Documentation files
    |   +-- Makefile                 # Commands to build the documentation
    |   +-- requirements.txt      #List of dependencies of the documentation        
    |   +-- conf.py                  # Configuration of the documentation
    |   +-- index.rst                # The main page of the documentation
    |   +-- material/  
    |   +-- dual_autodiff        #Tutorial notebook of the package              
    +-- tests/                       # Test folder
    |   +-- autodiff_tools.py        # Test suite for Dual class
    +-- Question5.py                 # Code for question 5 of the coursework
\end{verbatim}

\texttt{Pyproject.toml} is a configuration file used by Python packaging tools, it contains the build system requirements for a project.
\\
This file contains different sections:

\begin{enumerate}
    \item \textbf{A [project] section}: This section includes basic information about the package, such as its name, description, the name of the README file, project dependencies, and the required Python version. I also included a dynamic versioning setup using \texttt{dynamic = ["version"]}, as I use Git to tag versions whenever I make significant updates to the package.
    
    \item \textbf{A [Build system] section}: This section specifies the build backend (\texttt{build-backend}), and the tools required to build the package (\texttt{requires}).
    
    \item \textbf{A [tool.setuptools.packages.find] section}: This section tells \texttt{setuptools} where to find the Python package within the project repository. 

    Additionally, I added a \textbf{[tools.setuptools\_scm]} section, which allows the automatic determination of the version number based on my Git tags.
    
    I have also decided to include more information, such as the author’s name and email address, and the keywords of our package. This will be helpful if I decide to publish this package on PyPi, as they make my package easier to find.
\end{enumerate}


\section{\texttt{Dual} Class}
The main file of this package is called \texttt{dual.py}. It contains the core module of the \texttt{ Dual\_autodiff} package: the \texttt{Dual} class. This class defines a structure for dual numbers and performs standard operations on them. An instance of this class has two attributes: one to represent the real part of our number and another to represent the dual part of our number.

\vspace{10pt}

Automatic differentiation exploits the fact that every computer calculation executes a sequence of elementary arithmetic operations and functions; which highlights the importance of the next part.

\subsection{Operators}
\label{sec:part3}

The \texttt{Dual} class redefines the standard operators to make them compatible with dual numbers. The operators that are redefined are: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{**}, \texttt{/}, \texttt{//}, \texttt{\%}, \texttt{==}, \texttt{!=}. The redefinitions consider a wide range of cases, illustrated in the \hyperref[sec:details]{Details} section below.
The short-hand versions of these operators (\texttt{+=}, \texttt{-=}, etc.) are also redefined.

\subsubsection{Details}
\label{sec:details}
\begin{itemize}
    \item \textbf{The \texttt{\_\_add\_\_} and \texttt{\_\_radd\_\_} Methods} \\
    These methods redefine the \texttt{+} operator as follows:
     \begin{enumerate}
      \item \texttt{y.\_\_add\_\_(x)} is called for the following operations:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\):
        \[
        y + x = (a' + a) + (b' + b)\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y + x = (a' + x) + b'\epsilon
        \]
     \end{enumerate}
        \item If \(x\) is a scalar and \(y\) is a dual number, \texttt{y.\_\_radd\_\_(x)} is called for the following operation:
        \[
        x + y = (a' + x) + b'\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_sub\_\_} and \texttt{\_\_rsub\_\_} Methods} \\
    These methods redefine the \texttt{-} operator as follows:
    \begin{enumerate}
      \item \texttt{y.\_\_sub\_\_(x)} is called for the following operations:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\):
        \[
        y - x = (a' - a) + (b' - b)\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y - x = (a' - x) + b'\epsilon
        \]
     \end{enumerate}
        \item If \(x\) is a scalar and \(y\) is a dual number, \texttt{y.\_\_rsub\_\_(x)} is called for the following operation:
        \[
        x - y = (x - a') - b'\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_mul\_\_} and \texttt{\_\_rmul\_\_} Methods} \\
    These methods redefine the \texttt{*} operator as follows:
    \begin{enumerate}
        \item \texttt{y.\_\_mul\_\_(x)} is called for the following operations:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\):
        \[
        y * x = (a' \texttt{*} a) + (b' \texttt{*} a + b \texttt{*} a')\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y * x = (a' \texttt{*} x) + (b'\epsilon \texttt{*} x)
        \]
    \end{enumerate}
        \item If \(y\) is a dual number and \(x\) is a scalar, \texttt{y.\_\_rmul\_\_(x)} is called for the following operation:
        \[
        x * y = (a' \texttt{*} x) + (b'\epsilon \texttt{*} x)
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_truediv\_\_} and \texttt{\_\_rtruediv\_\_} Methods} \\
    These methods redefine the \(y / x\) operation as follows:
     \begin{enumerate}
        \item \texttt{y.\_\_truediv\_\_(x)} is called for the following operations:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\):
        \[
        y / x = \frac{a'}{a} + \frac{a*b' - b*a'}{a^2}\epsilon
        \]
        Explanation of this formula: 
        \[
		\frac{a + b \epsilon \cdot (a' - b' \epsilon)}{(a' + b' \epsilon)(a' - b' \epsilon)} =
		 \frac{a \cdot a' + b \cdot a \epsilon - a \cdot b' \epsilon - b b' \cdot \epsilon^2}{a'^2 - b'^2 \epsilon^2} = 
		 \frac{a}{a'} - \frac{b' *a-b*a'}{a'^2} \epsilon.
	\]
        and returns a \texttt{ZeroDivisionError} if the real part of \(x\) is zero.
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y / x = \frac{a'}{x} + \frac{b'}{x}\epsilon
        \]
        and returns a \texttt{ZeroDivisionError} if \(x\) is zero.
        \end{enumerate}
        \item If \(x\) is a scalar and \(y\) is a dual number, \texttt{y.\_\_rtruediv\_\_(x)} is called for the operation:
        \[
        x / y = \frac{x}{a'} - \frac{b' * x}{a' ^2}\epsilon
        \]
        Explanation of this formula: 
        \[
		\frac{x}{a' + b' \epsilon} = \frac{x \cdot (a' - b' \epsilon)}{(a' + b' \epsilon)(a' - b' \epsilon)} =
		 \frac{x \cdot a' - b' \cdot x \epsilon}{a'^2 - b'^2 \epsilon^2} =\frac{x}{a'} - \frac{b' x}{a'^2} \epsilon.
	\]
        and returns a \texttt{ZeroDivisionError} if \(y\) is zero.
    \end{enumerate}
    \textbf{Note:} The \texttt{\_\_floordiv\_\_} (\texttt{//}) and \texttt{\_\_mod\_\_} (\texttt{\%}) operators are defined using the same logic as above, by replacing \texttt{/} with \texttt{//} for the floor division and \texttt{\%} for the modulus operation.

    \item \textbf{The \texttt{\_\_pow\_\_} Method} \\
    This method redefines the \texttt{**} operator as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_pow\_\_(x)} is defined as:

\begin{enumerate}
    \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_pow\_\_(x)} is defined as:
    \begin{enumerate}
        \item If \(b = 0\):
        \begin{enumerate}
            \item If \(a' = 0\) and \(a = -1\): raises a \texttt{ZeroDivisionError}.
            \item If \(a = 0\): returns \(1\).
            \item Otherwise: 
            \[
            y^x = y^a = a'^{a} + \epsilon \cdot a \cdot a'^{(a-1)} \cdot b'.
            \]
        \end{enumerate}
        
        \item If \(b' \neq 0\): raises a \texttt{TypeError}.
    \end{enumerate}
    
    \item If \(y\) is a dual number and \(x\) is a scalar:
    \begin{enumerate}
        \item If \(a' = 0\) and \(x = -1\): raises a \texttt{ZeroDivisionError}.
        \item If \(x = 0\): returns \(1\).
        \item Otherwise:
        \[
        y^x = a'^x + x \cdot a'^{(x-1)} \cdot \epsilon.
        \]
    \end{enumerate}
\end{enumerate}

    \item \textbf{The \texttt{\_\_eq\_\_} and \texttt{\_\_ne\_\_} Methods} \\
    These methods redefine the \texttt{==} and \texttt{!=} operators as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), the equality is evaluated as:
        \[
        \text{if } (a == a') \text{ and } (b == b'),
        \]
        it returns \texttt{True} for \texttt{==} and \texttt{False} for \texttt{!=}.
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        \begin{aligned}
            &\text{if } (b' == 0): &\quad \text{if } (x == a'), &\quad \text{returns \texttt{True} for \texttt{==} and \texttt{False} for \texttt{!=}}. \\
            &                      &\quad \text{if } (x \neq a'), &\quad \text{returns \texttt{False} for \texttt{==} and \texttt{True} for \texttt{!=}}. \\
            &\text{if } (b' \neq 0): &\quad &\quad \text{returns \texttt{False} for \texttt{==} and \texttt{True} for \texttt{!=}}. \\
        \end{aligned}
        \]
    \end{enumerate}
    
    \item \textbf{The \texttt{\_\_gt\_\_}, \texttt{\_\_ge\_\_}, \texttt{\_\_le\_\_}, and \texttt{\_\_lt\_\_} Methods} \\
These methods redefine the \texttt{>}, \texttt{>=}, \texttt{<}, and \texttt{<=} operators respectively. The behavior for the operation \(x < y\) (and analogously for the other operators) is defined as follows:

\begin{enumerate}
    \item If both \(x\) and \(y\) are dual numbers with a null dual parts: \\
    The operator returns the comparison between their real parts:
    \[
    \text{if } x = a \text{ and } y = a', \quad \text{returns the result of } (a < a').
    \]

    \item If \(y\) is a scalar and \(x\) is a dual number with a null dual part: \\
    The operator returns the comparison between the real part of \(x\) and \(y\):
    \[
    \text{if } x = a \text{ and } y = y, \quad \text{returns the result of } (a < y).
    \]

    \item If \(x\) and \(y\) are dual numbers with non-null dual parts, or if \(y\) is a scalar and \(x\) is a dual number with a non-null dual part: \\
    The operator signals a warning indicating that the comparison is not defined for dual numbers. However, the operator ultimately returns the comparison between the real parts (as a personal choice)
    \end{enumerate}


    \item \textbf{The \texttt{\_\_neg\_\_} Method} \\
    This method redefines the \texttt{-} operator by negating the real and dual parts of \(x\), changing the real part to \(-a\) and the dual part to \(-b\).
  \item \textbf{Shorthand operators} \\
The method \texttt{\_\_iadd\_\_} redefines the shorthand operator \texttt{+=} using the same logic as \texttt{\_\_add\_\_}.
Similarly, the methods \texttt{\_\_isub\_\_}, \texttt{\_\_imul\_\_}, \texttt{\_\_itruediv\_\_}, \texttt{\_\_ipow\_\_}, \texttt{\_\_ifloordiv\_\_} and \texttt{\_\_imod\_\_} redefine the shorthand operators \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{**=}, \texttt{//=} and \texttt{\%=}respectively, using the same logic as their corresponding binary methods (\texttt{\_\_sub\_\_}, \texttt{\_\_mul\_\_}, \texttt{\_\_truediv\_\_}, \texttt{\_\_pow\_\_}).
\end{itemize}

\subsection{Functions}
The \texttt{Dual} class also defines essential functions to make them compatible with dual numbers. The essential functions defined are: exponential, sine, cosine, tangent, logarithm, ceil, floor, inverse, square, and abs.
Like the case of our operators, the definition of the functions also considers illegal calls for the functions: inverse, logarithm and tangent who raise \texttt{ZeroDivisionError}  to prevent a division by zero.

\subsubsection{Details}
The definition of essential functions lies completely on the f(a + b\epsilon\)) formula that was provided for us in the coursework sheet, which provides us with the formulas for the real part and the dual part of each of the functions:

\[
f(a + b\epsilon) = f(a) + f'(a)b\epsilon
\]
The real part corresponds to $f(a)$, and the dual part corresponds to $f'(a)b$.
The only work we have to do is compute the derivative of each essential functions we defined.

\begin{itemize}
    \item Derivative of $\exp(x)$ is $\exp(x)$.
    \item Derivative of $\log(x)$ is $1/x$, raising a \texttt{ZeroDivisionError} when the real part of $x=0$.
    \item Derivative of $\tan(x)$ is $1/\cos^2(x)$, raising a \texttt{ZeroDivisionError} when $\cos(x.real) \approx 0$ (detected using \texttt{np.isclose()}).
    \item Derivative of $\cos(x)$ is -$\sin(x)$.
    \item Derivative of $\sin(x)$ is $\cos(x)$.
    \item Derivative of $square(x)$ is 2$x$.
    \item Derivative of $inverse(x)$ is -1/$x^2$, raising a \texttt{ZeroDivisionError} when the real part of $x=0$.


\end{itemize}

For \texttt{abs(x)}, \texttt{floor(x)}, and \texttt{ceil(x)}, we just apply these to the real part and the dual part of the dual number x.

\section{Test Suite}

\label{sec:tests}
To ensure the reliability of our \texttt{Dual} class, a comprehensive test suite was developed. 
The \texttt{autodiff\_tools.py} file in the \texttt{tests} folder executes 51 tests on our class, with each test corresponding to a specific function in the dual.py file. 

We test a variety of dual numbers with both integer and float values for their real and dual parts. For functions and operations that raise errors (\texttt{ZeroDivisionError} and \texttt{TypeError}), invalid inputs were also tested to ensure the correct errors were raised.

\vspace{10pt}

For the operators, there is a test for every scenario:
\begin{enumerate}
    \item Operators between two dual numbers.
    \item Operators between a dual number and a scalar.
    \item Operators between a scalar and a dual number.
\end{enumerate}
These tests cover all possible combinations for each operator to ensure that the class behaves correctly each case.

\vspace{10pt}

To run the tests with pytest, after having installed the package, type the following command in your terminal from the project repository:

\begin{verbatim}
pytest -s tests/*
\end{verbatim}
\\

\textbf{Note}: If pytest is not installed in your environment, install it by running the following command:
\begin{verbatim}
pip install pytest
\end{verbatim}
\\ 

\section{Differentiating a function}
\label{sec:part5}
In this section, we use dual numbers to compute the derivative of the function \( f(x) = \log(\sin(x)) + x^2 \cos(x) \) (question 5 of the coursework). Three functions are defined in the \texttt{question5.py} file:
\begin{enumerate}
    \item A function to compute the numerical derivative of \( f(x) \) with a step size \( h \), 
     \[
    f\_numerically(x) =  \frac{f(x+h) - f(x)}{h} \).
     \]
     \item A function that evaluates the analytical derivative of the function at a point x (which I found manually): 
    \[
    f\_analytical(x) = \frac{\cos(x)}{\sin(x)} + 2x\cos(x) - x^2 \sin(x).
    \]
    \item A function that finds the derivative of f(x) using dual numbers,
    \[ f\_AD(x) = (x.\text{cos}()  \texttt{*} x.\text{square}() + (x.\text{sin}()).\text{log}()).
    \]
    \end{enumerate}
    
  We simply initialize a dual number \( x_1 = \text{Dual}(x, 1) \), since \( b = 1 \), the derivative with respect to \( x \) is the dual part of \( f\_AD(x1) \), as shown by the formula provided in the coursework:
\[
f(a + b\epsilon) = f(a) + f'(a)b\epsilon.
\]


\subsection{Observations}

We observe that the analytical derivative and the derivative computed through dual numbers are exactly the same, with the same values up to the 16th decimal point, which is the maximum precision for numpy (since the Dual class uses \texttt{float64} by default for both the real and dual parts of the dual numbers). 

I have also defined a time decorator to see how long each function takes to execute. Both the analytical derivative and the dual numbers derivative are computed in a time order of 1e-5 seconds. The analytical one seems to compute slightly faster, which is expected as the analytical approach involves pre-computed derivatives, while dual numbers compute the derivative from scratch, using function evaluation. This illustrates the usefulness of dual numbers, as they save a lot of effort and eventually time when differentiating.
\\

Figure 1 below illustrates that as the step size gets smaller, the numerical derivative approaches the true analytical value (the plot was obtained using the \texttt{numerical\_values()} function in \texttt{question5.py}). Additionally, we observe that beyond a certain threshold, when the step size becomes too small, the numerical derivative values deviate from the analytical value.
 \begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Fig1} 
    \caption{Analytical and Numerical Derivatives for Different Step Sizes}
\end{figure}

More precisely, the \texttt{interval()} function examines what happens in the interval of steps \([1e-16, 1e-13]\). Figure 2 shows that for smaller step sizes than \(1e-13\), the numerical derivatives start to oscillate heavily, which is caused by the limitations of floating-point precision and round-off errors that become more pronounced as the step size gets infinitely small.

 \begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Fig2} 
    \caption{Zoom on the Analytical and Numerical Derivatives for Different Step Sizes}
\end{figure}

\section{Documentation}
\label{sec:documentation}
Since the first file created in my package, the code was documented using docstrings. Each function includes a docstring that describes its purpose, parameters, returns values and potential errors raised, which was very helpful when generating the Sphinx documentation. The structure mirrors the \texttt{Read the Docs} page of the C1 course, as I used a theme provided by Read the Docs (\texttt{sphinx\_rtd\_theme}). 

\vspace{10pt}

To generate the html pages of the documentation, after having installed the package,  please run the following command in your terminal from docs folder:
\begin{verbatim}
make install
make clean
make html
\end{verbatim}
The documentation can be viewed by opening docs/build/html/index.html in a web browser.

The \texttt{make html} command installs all the required dependencies for building the documentation from the \texttt{requirements.txt} file.
\section{Cythonized version of the package}

After Cythonizing the package, we compared the performance of the Cythonized version (\texttt{dual\_autodiff\_x}) and the normal version (\texttt{dual\_autodiff}) in the \texttt{dual\_autodiff.ipynb} notebook.

First, I initialized the same dual numbers using both \texttt{dual\_autodiff\_x} and \texttt{dual\_autodiff}.  
Then, I tested the same functions on both versions and verified key equalities to ensure they produced identical results.

To compare the performance of operators and functions, I used the \texttt{\%timeit} magic command. The results (shown in the figures) demonstrate that the Cythonized version performs almost twice as fast for our operators and other functions.  
Additionally, I defined:
\begin{itemize}
    \item A function \texttt{f()} that loops 1,000 times, applying various functions.
    \item A loop that performs 10,000 multiplications.
\end{itemize}


To see how the performance of the two packages changes with the number of iterations, I used Python’s \texttt{timeit} module and iterated over different loop counts to measure execution times for both versions. The results are displayed in Figures \ref{fig:fig3} and \ref{fig:fig4} (reproducible from the \texttt{dual\_autodiff} notebook).  
 \begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{oper} 
    \caption{Comparison of the Performance of Different Operators Applied on \texttt{Dual\_autodiff} and \texttt{Dual\_autodiff_x}}
    \label{fig:fig3}
\end{figure}
 \begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{func} 
    \caption{Comparison of the Performance of Different Functions Applied on \texttt{Dual\_autodiff} and \texttt{Dual\_autodiff_x}}
    \label{fig:fig4}
\end{figure}

We observe that, as the number of iterations increases, the performance gap widens dramatically for the operators. This increase is less pronounced for functions but still evident.

\vspace{10pt}

After having completed the C1 course this semester, we can explain the reasons behind these differences in performance:
\begin{enumerate}
    \item \textbf{For the functions (e.g., \texttt{sin()}, \texttt{cos()}, etc.):}  
    The NumPy module is used in \texttt{dual.py}. In the pure Python version, Python performs type checking and memory management before calling the NumPy functions. In contrast, the Cythonized version compiles these calls directly to C at runtime, reducing overhead and improving execution time.

    \item \textbf{For the operators:}  
    The Cythonized version executes these operations as pure C operations, avoiding Python's overhead. This makes the Cythonized operators approximately twice as fast.
\end{enumerate}

\vspace{10pt}

This performance improvement can be particularly useful in machine learning, where automatic differentiation can be performed significantly faster using the Cythonized version.


\section{Summary}
To summarise, this report described the steps in the creation of the \texttt{dual\_autodiff} package that can successfully perform  \hyperref[sec:part5]{automatic differentiation} using dual numbers, which was possible by the redefinitions of basic arithmetic operators and functions (\hyperref[sec:part3]{section 3}). The package is \hyperref[sec:documentation]{documented} and reliable, as it passes a wide range of \hyperref[sec:tests]{tests}. Finally, after cynthonising the package, we noticed a significant difference in the performance of the functions and operators; which can be particularly useful in machine learning to enable fast training of deep neural networks.

\section{Declaration of AI Tools}
ChatGPT was the only AI tool used in the creation of this project. It was only used to correct spelling mistakes in this report, and correct my .tex file (source of this LATEX report). 

\section{\textcolor{red}{Important Notes:}}

\begin{itemize}
    \item Please make sure you are using Python 3.9 or a newer version when importing and using the \texttt{dual\_autodiff} package.
    
    \item If you are creating a virtual environment to download the package, please ensure that Python 3.9 or newer is used to create the virtual environment. Also, make sure to upgrade \texttt{pip} by running the following command inside your environment:
    \begin{verbatim}
    python3.9 -m pip install --upgrade pip
    \end{verbatim}
    (Older versions of \texttt{pip} cannot install your package in editable mode without a \texttt{setup.py} file.)
    
    \item If you are in the directory that directly contains the main project repository (where the \texttt{dual\_autodiff} package is located), use the following command in Python to import the package:
    \begin{verbatim}
    from dual_autodiff.dual import dual
    \end{verbatim}
    in Python to import the package instead of \texttt{import dual\_autodiff as df}. This is because the system treats \texttt{dual\_autodiff} as a folder rather than a package in this directory.
\end{itemize}

\section{References}
\begin{enumerate}
    \item \url{https://en.wikipedia.org/wiki/Automatic_differentiation}
    \item \url{https://github.com/borisbolliet/ResearchComputing/tree/main/docs}
\end{enumerate}

\end{document}

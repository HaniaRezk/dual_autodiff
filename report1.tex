\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{xcolor}

\title{\Huge \textbf{C1 Research Computing Coursework Report}} 
\author{Hania Rezk (hhmmer2) \\ 
\\
MPhil Data Intensive Science, Department of Physics}
\date{26 November 2024}

\begin{document}

\maketitle


\noindent \textbf{Word count:} [1000] \\

\newpage  
\tableofcontents

\newpage  


\section{Introduction}
This report discusses the development of a Python package that performs automatic differentiation using dual numbers. Dual numbers, represented as $x = a + b\epsilon$, consist of a real part $a$, and a dual part $b$ carried by $\epsilon$ that satisfies $\epsilon^2 = 0$. These numbers are used to compute derivatives efficiently; this approach, called forward-mode automatic differentiation, is particularly valuable in fields like machine learning as it enables fast training of deep neural networks.

This report describes the step-by-step creation of this package and answers the questions of the coursework sheet. First, we will overview the global structure of the package (question 2 of CW) and present the \texttt{Dual} class which allows us to represent and perform operations on dual numbers. Secondly, a test suite that covers a meaningful range of cases was implemented to make sure our \texttt{Dual} class works as expected. Using this same class, this package differentiates a function and compares the result to the analytical and numerical derivatives to measure the precision of automatic differentiation (question 5 of CW). Finally, we will Cythonize the package and compare its performance to the pure Python version (question 8 of CW). The entirety of the code is documented according to the good practices taught in the Research Computing module.

\section{Package Structure and Project Configuration}
This package respects the structure seen in the Research Computing course as shown below.

\begin{verbatim}
    .
    +-- pyproject.toml               # Configuration 
    +-- README.md                    # Instructions
    +-- dual_autodiff/               # Package folder with codes
    |   +-- __init__.py
    |   +-- version.py               # Manage package versions
    |   +-- dual.py                  # Dual class
    +-- dist/                        # Distribution files
    +-- docs/                        # Documentation files
    |   +-- Makefile                 # Commands to build the documentation
    |   +-- requirements.txt              
    |   +-- conf.py                  # Configuration of the documentation
    |   +-- index.rst                # The main page of the documentation
    |   +-- material/                
    +-- tests/                       # Test folder
    |   +-- autodiff_tools.py        # Test suite for Dual class
    +-- Question5.py                 # Code for question 5 of the coursework
\end{verbatim}


\section{\texttt{Dual} Class}
The main file of this package is called \texttt{dual.py}. It contains the core module of our package and defines the \texttt{Dual} class. This class defines a structure for dual numbers and performs standard operations on them. An instance of this class has two attributes: one to represent the real part of our number and another to represent the dual part of our number.

Automatic differentiation exploits the fact that every computer calculation executes a sequence of elementary arithmetic operations and functions; this highlights the importance of the next part.

\subsection{Operators}
The \texttt{Dual} class redefines the standard operators to make them compatible with dual numbers. The operators that are redefined are: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{**}, \texttt{/}, \texttt{//}, \texttt{\%}, \texttt{==}, \texttt{!=}. The redefinitions consider a wide range of cases, illustrated in the \texttt{Details} section.
Short-hand versions of the operators (\texttt{+=}, \texttt{-=}, etc.) are also redefined.

\subsubsection{Details}
\begin{itemize}
    \item \textbf{The \texttt{\_\_add\_\_} and \texttt{\_\_radd\_\_} Methods} \\
    These methods redefine the \texttt{+} operator as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_add\_\_(x)} is called for the operation:
        \[
        y + x = (a' + a) + (b' + b)\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y + x = (a' + x) + b'\epsilon
        \]
        \item If \(x\) is a dual number and \(y\) is a scalar, \texttt{y.\_\_radd\_\_(x)} is called for the operation:
        \[
        x + y = (a + y) + b\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_sub\_\_} and \texttt{\_\_rsub\_\_} Methods} \\
    These methods redefine the \texttt{-} operator as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_sub\_\_(x)} is called for the operation:
        \[
        y - x = (a' - a) + (b' - b)\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y - x = (a' - x) + b'\epsilon
        \]
        \item If \(x\) is a dual number and \(y\) is a scalar, \texttt{y.\_\_rsub\_\_(x)} is called for the operation:
        \[
        x - y = (a - y) + b\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_mul\_\_} and \texttt{\_\_rmul\_\_} Methods} \\
    These methods redefine the \texttt{*} operator as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_mul\_\_(x)} is called for the operation:
        \[
        y * x = (a' \texttt{*} a) + (b' \texttt{*} a + b \texttt{*} a')\epsilon
        \]
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y * x = (a' \texttt{*} x) + b'\epsilon
        \]
        \item If \(x\) is a dual number and \(y\) is a scalar, \texttt{y.\_\_rmul\_\_(x)} is called for the operation:
        \[
        x * y = (a \texttt{*} y) + b\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_truediv\_\_} and \texttt{\_\_rtruediv\_\_} Methods} \\
    These methods redefine the \(y / x\) operation as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_truediv\_\_(x)} is called for the operation:
        \[
        y / x = \frac{a'}{a} + \frac{a*b' - b*a'}{a^2}\epsilon
        \]
        and returns an error if the real part of \(x\) is zero.
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y / x = \frac{a'}{x} + \frac{b'}{x}\epsilon
        \]
        and returns an error if \(x\) is zero.
        \item If \(x\) is a dual number and \(y\) is a scalar, \texttt{y.\_\_rtruediv\_\_(x)} is called for the operation:
        \[
        x / y = \frac{a}{y} + \frac{b}{y}\epsilon
        \]
        and returns an error if \(y\) is zero.
    \end{enumerate}

    \item \textbf{The \texttt{\_\_pow\_\_} Method} \\
    This method redefines the \texttt{**} operator as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), \texttt{y.\_\_pow\_\_(x)} is defined as:
        \begin{aligned}
            &\text{if } (b' == 0): y ** x = a' \texttt{**} x + \epsilon\ x \texttt{*}a' \texttt{**} (x-1) \\
            &\text{if } (b' \neq 0): \text{returns an error}. \\
        \end{aligned}
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        y ** x = a' \texttt{**} x + x \texttt{*} a' \texttt{**} (x-1)\epsilon
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_eq\_\_} and \texttt{\_\_ne\_\_} Methods} \\
    These methods redefine the \texttt{==} and \texttt{!=} operators as follows:
    \begin{enumerate}
        \item If both \(x\) and \(y\) are dual numbers, \(y = a' + b'\epsilon\) and \(x = a + b\epsilon\), the equality is evaluated as:
        \[
        \text{if } (a == a') \text{ and } (b == b'),
        \]
        it returns \texttt{True} for \texttt{==} and \texttt{False} for \texttt{!=}.
        \item If \(y\) is a dual number and \(x\) is a scalar:
        \[
        \begin{aligned}
            &\text{if } (b' == 0): &\quad \text{if } (x == a'), &\quad \text{return \texttt{True} for \texttt{==} and \texttt{False} for \texttt{!=}}. \\
            &                      &\quad \text{if } (x \neq a'), &\quad \text{return \texttt{False} for \texttt{==} and \texttt{True} for \texttt{!=}}. \\
            &\text{if } (b' \neq 0): &\quad &\quad \text{return \texttt{False} for \texttt{==} and \texttt{True} for \texttt{!=}}. \\
        \end{aligned}
        \]
    \end{enumerate}

    \item \textbf{The \texttt{\_\_neg\_\_} Method} \\
    This method redefines the \texttt{-} operator by negating the real and dual parts of \(x\), changing the real part to \(-a\) and the dual part to \(-b\).
  \item \textbf{Shorthand operators} \\
The method \texttt{\_\_iadd\_\_} redefines the shorthand operator \texttt{+=} using the same logic as \texttt{\_\_add\_\_}.
Similarly, the methods \texttt{\_\_isub\_\_}, \texttt{\_\_imul\_\_}, \texttt{\_\_itruediv\_\_}, and \texttt{\_\_ipow\_\_} redefine the shorthand operators \texttt{-=}, \texttt{*=}, \texttt{/=}, and \texttt{**=}, respectively, using the same logic as their corresponding binary methods (\texttt{\_\_sub\_\_}, \texttt{\_\_mul\_\_}, \texttt{\_\_truediv\_\_}, \texttt{\_\_pow\_\_}).
\end{itemize}

\subsection{Functions}
The \texttt{Dual} class also defines essential functions to make them compatible with dual numbers. The essential functions defined are: exponential, sine, cosine, tangent, logarithm, ceil, floor, inverse, square, and abs.
Like the case of our operators, the definition of our functions also considers illegal calls for the functions : inverse logarithm and tangent, and an error is raised to prevent a division by zero.

\subsubsection{Details}
The definition of essential functions lies completely on the f(a + b\epsilon\)) formula that was provided for us in the coursework sheet, which provides us with the formulas for the real part and the dual part of the returns of each of our functions:

\[
f(a + b\epsilon) = f(a) + f'(a)b\epsilon
\]
The real part corresponds to $f(a)$, and the dual part corresponds to $f'(a)b$.
The only work we have to do is compute the derivative of each essential functions we defined.

\begin{itemize}
    \item Derivative of $\exp(x)$ is $\exp(x)$.
    \item Derivative of $\log(x)$ is $1/x$, raising a \texttt{ZeroDivisionError} when the real part of $x=0$.
    \item Derivative of $\tan(x)$ is $1/\cos^2(x)$, raising a \texttt{ZeroDivisionError} when $\cos(x.real) \approx 0$ (detected using \texttt{np.isclose()}).
    \item Derivative of $\cos(x)$ is -$\sin(x)$.
    \item Derivative of $\sin(x)$ is $\cos(x)$.
    \item Derivative of $square(x)$ is 2$x$.
    \item Derivative of $inverse(x)$ is -1/$x^2$, raising a \texttt{ZeroDivisionError} when the real part of $x=0$.


\end{itemize}

For \texttt{abs(x)}, \texttt{floor(x)}, and \texttt{ceil(x)}, we just apply these to the real part and the dual part of the dual number x.

\section{Test Suite}
To ensure the reliability of our \texttt{Dual} class, a comprehensive test suite was developed. 
The \texttt{autodiff\_tools.py} file in the \texttt{tests} folder executes 31 tests on our class, with each test corresponding to a specific function in the dual.py file. We tested a variety of dual numbers with both integer and float values for their real and dual parts. For functions that raise errors, invalid inputs were also tested to ensure the correct errors were produced.
To run the tests with pytest, after having installed the package, type the following command in your terminal from the project repository:

\begin{verbatim}
pytest -s tests/*
\end{verbatim}
\\

\textbf{Note}: If pytest is not installed in your environment, install it by running the following command:
\begin{verbatim}
pip install pytest
\end{verbatim}
\\

\section{Differentiating a function}
\section{Documentation}
Since the first file created in my package, I made sure to document my code using docstrings. Each function includes a docstring that describes its purpose, parameters and returns values, which was very helpful when generating the Sphinx documentation. The structure mirrors the \texttt{Read the Docs} page of the C1 course, as I used a theme provided by Read the Docs ('sphinx\_rtd\_theme'), and copied the structure of the docs folder in the GitHub repository of the research computing course created by Dr. Boris Bolliet. 
To generate the html pages of the documentation, after having installed the package,  please run the following command in your terminal from docs folder:
\begin{verbatim}
make clean
make html
\end{verbatim}
The documentation can be viewed by opening docs/build/html/index.html in a web browser.
\\

\textbf{Note}: The \texttt{make install} command installs all the required packages in your environment to correctly generate the documentation.
\\
\section{Questions 8-9}
\section{Summary}
\section{Declaration of AI Tools}
ChatGPT was the only AI tool used in the creation of this project. It was primarily used to correct spelling mistakes in this report, and correct my .tex file (source of this LATEX report). However, the entire report was written by me and I didn’t use any sentence reconstruction recommendations. ChatGPT was also used to generate values of the dual numbers used in my tests and provided me with the results of the operations on these numbers: It did not write the code or any part of it, it just gave me an output that looks like this: 
\\

\textbf{Example of Dual Numbers Addition:}
\[
x = \text{Dual}(5, 3), \quad y = \text{Dual}(2, 4), \quad x + y = \text{Dual}(7, 7)
\]
\section{\textcolor{red}{Important Notes:}}

\begin{itemize}
    \item Please make sure you are using Python 3.9 or a newer version when importing and using the \texttt{dual\_autodiff} package.
    
    \item If you are creating a virtual environment to download the package, please ensure that Python 3.9 or newer is used to create the virtual environment. Also, make sure to upgrade \texttt{pip} by running the following command inside your environment:
    \begin{verbatim}
    python3.9 -m pip install --upgrade pip
    \end{verbatim}
    (Older versions of \texttt{pip} cannot install your package in editable mode without a \texttt{setup.py} file.)
    
    \item If you are in the directory that directly contains the main project repository (where the \texttt{dual\_autodiff} package is located), use the following command in Python to import the package:
    \begin{verbatim}
    from dual_autodiff.dual import dual
    \end{verbatim}
    in Python to import the package instead of \texttt{import dual\_autodiff as df}. This is because the system treats \texttt{dual\_autodiff} as a folder rather than a package in this directory.
\end{itemize}

\section{References}
\begin{enumerate}
    \item \url{https://en.wikipedia.org/wiki/Automatic_differentiation}
    \item \url{https://github.com/borisbolliet/ResearchComputing/tree/main/docs}
\end{enumerate}

\end{document}
